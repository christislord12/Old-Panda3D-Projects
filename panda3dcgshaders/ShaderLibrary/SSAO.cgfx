
float Script : STANDARDSGLOBAL <
	string UIWidget = "None";
	string ScriptClass = "Scene";
	string ScriptOrder = "PostProcess";
	string ScriptOutput = "Color";
	string Script = "Technique=MyTechnique;";
> = 0.8;

#include "Functions.cgfx"

float4x4 WorldViewProjection : WORLDVIEWPROJECTION <string UIWidget = "None";>;
float4x4 WorldView : WORLDVIEW <string UIWidget = "None";>;
float2 ViewPortPixelSize : VIEWPORTPIXELSIZE < string UIWidget = "None";>;

float ClearDepth <string UIWidget = "None";> = 1.0;
float4 ClearColor <string UIWidget = "Color";> = { 0.0, 0.0, 0.2, 1.0 };

float SSAOScale <string UIWidget = "Slider"; float UIMin = 0.0; float UIMax = 1.0; float UIStep = 0.001;> = 0.05f;
float SSAOFalloff <string UIWidget = "Slider"; float UIMin = 0.0; float UIMax = 1.0; float UIStep = 1e-9;> = 1e-5;
float SSAOBlurThreshold <string UIWidget = "Slider"; float UIMin = 0.0; float UIMax = 1.0; float UIStep = 0.001;> = 0.1;

texture SceneColorTexture1 : RENDERCOLORTARGET <
	float2 ViewPortRatio = {1.0, 1.0};
	string Format = "A8R8G8B8";
	string UIWidget = "None";
>;
sampler2D SceneColorSampler1 = sampler_state {
	texture = <SceneColorTexture1>;
	MagFilter = Linear;
	MinFilter = Linear;
};

texture SceneColorTexture2 : RENDERCOLORTARGET <
	float2 ViewPortRatio = {1.0, 1.0};
	string Format = "A8R8G8B8";
	string UIWidget = "None";
>;
sampler2D SceneColorSampler2 = sampler_state {
	texture = <SceneColorTexture2>;
	MagFilter = Linear;
	MinFilter = Linear;
};

texture SceneDepthTexture : RENDERDEPTHSTENCILTARGET <
	float2 ViewPortRatio = {1.0, 1.0};
	string Format = "D24S8";
	string UIWidget = "None";
>;

/*
Without choosing a correct WrapS and WrapT the normals may bleed accross the
image boundaries.

If the Format is A8R8G8B8 the normals and depth values have to mapped to
positive only values in the first pass. They need to be unmapped in the SSAO
pass then. A32B32G32R32F was only choosen for convenience, especially the
normals do not need that much precision.
*/
texture SceneNormalDepthTexture : RENDERCOLORTARGET <
	float2 ViewPortRatio = {1.0, 1.0};
	int MipLevels = 1;
	string Format = "A32B32G32R32F";
	string UIWidget = "None";
>;
sampler2D SceneNormalDepthSampler = sampler_state {
	texture = <SceneNormalDepthTexture>;
	MagFilter = Linear;
	MinFilter = Linear;
	WrapS = ClampToEdge;
	WrapT = ClampToEdge;
};

/*
In a real world example (especially in deffered shading/lighting), normals are
generated by pass that only cares about filling all render targets. Each objec
than have its own normal map (obviously). But in this simple example we only use
one normal map for all objects.
*/
texture NormalTexture <>;
sampler2D NormalSampler = sampler_state {
	Texture = <NormalTexture>;
	MinFilter = Linear;
	MagFilter = Linear;
};

texture SSAONoiseTexture <>;
sampler2D SSAONoiseSampler = sampler_state {
	Texture = <SSAONoiseTexture>;
	MinFilter = Linear;
	MagFilter = Linear;
	WrapS = Repeat;
	WrapT = Repeat;
};

/*
Structs and programs for generating a texture that contains the eye space
normals and the depth value (The depth value is normally already in the depth
buffer). In real world SSAO implementation the scene is renedered multiple
times, therefore the it is perhaps possible that the depth buffer is not
available anymore or need to be saved seperatly.
*/

struct NormalDepthVertexIn {
	float4 positionObject : POSITION;
	float2 texcoord : TEXCOORD0;
	float3 tangentObject : TANGENT;
	float3 bitangentObject : BINORMAL;
	float3 normalObject : NORMAL;
};

struct NormalDepthVertexOutFragmentIn {
	float4 positionClip : POSITION;
	float2 texcoord : TEXCOORD0;
	float3 tangentEye : TEXCOORD1;
	float3 bitangentEye : TEXCOORD2;
	float3 normalEye : TEXCOORD3;
	float4 positionProjection : TEXCOORD4;
};

struct NormalDepthFragmentOut {
	float4 color : COLOR;
};

void NormalDepthVertexProgram(in NormalDepthVertexIn i, out NormalDepthVertexOutFragmentIn o) {
	o.positionClip = mul(WorldViewProjection, i.positionObject);
	o.texcoord = i.texcoord;
	o.tangentEye = normalize(mul(float3x3(WorldView), i.tangentObject)); // TODO inverse transpose
	o.bitangentEye = normalize(mul(float3x3(WorldView), i.bitangentObject)); // TODO inverse transpose
	o.normalEye = normalize(mul(float3x3(WorldView), i.normalObject)); // TODO inverse transpose
	o.positionProjection = mul(WorldViewProjection, i.positionObject);
}

void NormalDepthFragmentProgram(in NormalDepthVertexOutFragmentIn i, out NormalDepthFragmentOut o) {

	float3 normalTexture = tex2D(NormalSampler, i.texcoord).rgb * 2.0 - 1.0;
	float3 normalEye = float3(0.0, 0.0, 0.0);
	normalEye += i.tangentEye * normalTexture.x;
	normalEye += i.bitangentEye * normalTexture.y;
	normalEye += i.normalEye * normalTexture.z;
	normalEye = normalize(normalEye);

	//float3 normalEye = normalize(i.normalEye);

	float depth = (i.positionProjection.z / i.positionProjection.w) * 0.5 + 0.5; // OpenGL is from -1.0 to 1.0

	o.color = float4(normalEye, depth);
}

/*
Structs and programs for the Screen Space Ambient Occlusion pass.
*/

// UIWidget = "None" on arrays, seems not to work with FX Composer 2.5
const float3 SPHERE[] = {
	float3(-0.806888, 1.305572, 0.000000),
	float3(-0.696112, 0.000000, 0.430221),
	float3(0.000000, 0.312072, 0.504944),
	float3(-1.159753, 0.716767, 0.442986),
	float3(-0.227694, 0.596109, 0.368416),
	float3(-0.366756, 0.226667, 0.593423),
	float3(-0.209719, 0.339332, 0.000000),
	float3(0.000000, 0.175173, 0.283436),
	float3(0.296116, 0.479125, 0.000000),
	float3(-0.235356, 0.616170, 0.380814),
	float3(0.000000, 1.137977, 0.000000),
	float3(0.291803, 0.763950, 0.472147),
	float3(-0.328684, 0.531822, 0.000000),
	float3(0.268044, 0.433704, 0.000000),
	float3(0.000000, 0.940501, -1.521763),
	float3(0.000000, 1.145462, 0.000000),
	float3(-0.299736, 0.784720, -0.484984),
	float3(0.289819, 0.758756, -0.468937),
	float3(-0.779022, 1.260484, 0.000000),
	float3(0.000000, 0.896649, -1.450809),
	float3(-1.318164, 0.000000, -0.814670),
	float3(-0.002311, 0.006050, -0.003739),
	float3(-0.338730, 0.209346, -0.129383),
	float3(-0.133032, 0.082218, -0.215250),
	float3(-0.573085, 0.927271, 0.000000),
	float3(-0.694514, 0.000000, -0.429233),
	float3(-1.175849, 0.000000, 0.726715),
	float3(-0.115182, 0.071186, -0.043996),
	float3(-0.046465, 0.028717, 0.017748),
	float3(-0.609563, 0.000000, 0.000000),
	float3(0.451058, 0.729827, 0.000000),
	float3(0.000000, 0.464186, 0.751069),
	float3(0.280005, 0.000000, 0.173053),
	float3(0.252299, 0.660528, 0.408229),
	float3(0.641974, 0.396762, 0.245212),
	float3(0.198153, 0.122465, 0.320619),
	float3(0.000000, 0.941854, 1.523952),
	float3(-0.438061, 0.000000, 0.270737),
	float3(0.000000, -0.193834, 0.313630),
	float3(-0.535580, 0.331006, 0.866586),
	float3(0.000000, 0.000000, 0.246942),
	float3(-0.737887, -0.456039, 1.193926),
	float3(-1.362708, 0.000000, 0.842200),
	float3(-1.551245, 0.000000, -0.958722),
	float3(-0.358339, -0.579805, 0.000000),
	float3(-0.505288, 0.000000, 0.000000),
	float3(-0.014298, -0.008837, 0.005461),
	float3(-1.113163, -0.687972, -0.425190),
	float3(-0.653914, 0.000000, -0.404141),
	float3(0.000000, 0.115465, -0.186826),
	float3(0.000000, -0.627985, -1.016100),
	float3(-0.194690, 0.120325, -0.315015),
	float3(-0.481981, -0.297881, -0.779862),
	float3(0.000000, 0.000000, -0.538087),
	float3(0.000000, 0.348652, -0.564130),
	float3(0.777650, 1.258264, 0.000000),
	float3(1.082471, 0.000000, -0.669004),
	float3(0.137046, 0.358791, -0.221745),
	float3(0.619629, 0.382952, -1.002580),
	float3(0.203311, 0.125653, -0.077658),
	float3(0.846344, -1.369413, 0.000000),
	float3(0.936641, 0.000000, 0.578876),
	float3(0.000000, -0.887851, 1.436573),
	float3(0.466347, -0.288218, 0.178129),
	float3(0.017148, -0.044894, 0.027746),
	float3(0.325565, -0.201210, 0.526775),
	float3(0.934658, -1.512308, 0.000000),
	float3(0.000000, -0.464560, 0.751673),
	float3(-0.645093, -1.043782, 0.000000),
	float3(0.187887, -0.491896, 0.304008),
	float3(0.000000, -0.452203, 0.000000),
	float3(-0.025435, -0.066589, 0.041155),
	float3(0.951399, -1.539395, 0.000000),
	float3(-0.447005, -0.723269, 0.000000),
	float3(0.000000, -0.217732, -0.352299),
	float3(0.000000, -1.126782, 0.000000),
	float3(0.485186, -1.270233, -0.785047),
	float3(-0.301853, -0.790261, -0.488408),
	float3(0.197507, -0.319573, 0.000000),
	float3(0.000000, -0.921449, -1.490935),
	float3(0.929217, 0.000000, -0.574288),
	float3(0.137863, -0.360931, -0.223067),
	float3(0.782062, -0.483341, -0.298721),
	float3(0.571348, -0.353112, -0.924460),
	float3(0.174765, -0.282775, 0.000000),
	float3(1.408792, 0.000000, -0.870681),
	float3(0.419851, 0.000000, 0.259482),
	float3(0.191103, -0.118108, -0.072995),
	float3(1.157959, -0.715658, 0.442301),
	float3(0.865909, 0.000000, 0.000000),
	float3(0.000000, -0.387466, 0.626933),
	float3(0.857073, 0.000000, 0.529700),
	float3(0.000000, 0.672484, 1.088103),
	float3(0.381403, -0.235720, 0.617123),
	float3(0.000000, 0.000000, 0.873725),
	float3(0.354493, 0.219089, 0.573582),
	float3(-0.283910, -0.459376, 0.000000),
	float3(0.000000, -0.073950, 0.119653),
	float3(-0.615062, 0.000000, 0.380129),
	float3(-0.211598, -0.553970, 0.342372),
	float3(-0.127196, -0.078612, 0.048585),
	float3(-0.337741, -0.208735, 0.546476),
	float3(0.000000, -0.383867, -0.621110),
	float3(-0.416063, -0.673204, 0.000000),
	float3(-1.398828, 0.000000, -0.864523),
	float3(-0.141013, -0.369176, -0.228163),
	float3(-0.415634, -0.256876, -0.672510),
	float3(-0.778285, -0.481007, -0.297278),
	float3(0.443408, 0.000000, -0.274041),
	float3(0.000000, -0.393585, -0.636834),
	float3(0.000000, 0.881227, -1.425856),
	float3(0.004536, -0.002803, -0.007339),
	float3(0.218737, 0.135187, -0.353923),
	float3(0.000000, 0.000000, -0.762490),
	float3(0.121985, 0.000000, 0.075391),
	float3(1.057326, 0.000000, -0.653464),
	float3(0.810834, 1.311957, 0.000000),
	float3(1.373954, 0.000000, 0.000000),
	float3(0.284887, 0.176070, 0.108817),
	float3(0.269068, 0.166293, -0.102775),
};

struct SSAOVertexIn {
	float3 positionObject : POSITION;
	float2 texcoord : TEXCOORD0;
};

struct SSAOVertexOutFragmentIn {
	float4 positionClip : POSITION;
	float2 texcoord : TEXCOORD0;
};

struct SSAOFragmentOut {
	float4 color : COLOR;
};

void SSAOVertexProgram(in SSAOVertexIn i, out SSAOVertexOutFragmentIn o) {
	o.positionClip = float4(i.positionObject.xyz, 1.0);
	o.texcoord = i.texcoord;
}

/*
Both SSAOFalloff and SSAOScale currently heavy depend on the depth buffer
properties (which depend on the camera settings, especially the near and far
plane settings). A more carefully designed implementation should behave better
than this (how the depth value is stored, is perhaps important as well).

TODO

One idea was, that SSAOScale should depenth on the depth itself. The idea should
be that, the deeper the depth buffer, the smaller the radius of the sphere. The
idea is not that bad, but in no implementation there was any visible differnce
(perhaps the choosen scene is not that good).
*/
void SSAOFragmentProgram(in SSAOVertexOutFragmentIn i, out SSAOFragmentOut o, uniform sampler2D samplerDepthNormal) {
	float4 currentDepthNormal = tex2D(samplerDepthNormal, i.texcoord);

	//o.color = float4(currentDepthNormal.w, currentDepthNormal.w,currentDepthNormal.w, 1.0); // debug depth
	//o.color = float4(currentDepthNormal.xyz * 0.5 + 0.5, 1.0); // debug normals

	float3 random = normalize(tex2D(SSAONoiseSampler, i.texcoord * 13.0).rgb * 2.0 - 1.0);

	//o.color = float4(random * 0.5 + 0.5, 1.0); // debug random

	float3 eye = float3(i.texcoord.xy, currentDepthNormal.w);
	float occlusionSum = 0.0;
	const float sampleWeight = 1.0 / 32.0;
	for(int i = 0; i < 32; i++)
	{
		float3 randomRay = SSAOScale * reflect(SPHERE[i], random);
		float3 ray = eye + randomRay * sign(dot(randomRay, currentDepthNormal.xyz));
		float4 sampleDepthNormal = tex2D(samplerDepthNormal, ray.xy);
		float depthDifference = currentDepthNormal.w - sampleDepthNormal.w;
		float occlusionNormal = 1.0 - dot(sampleDepthNormal.xyz, currentDepthNormal.xyz);
		float occlusionDepth = step(SSAOFalloff, depthDifference) * (1.0 - smoothstep(SSAOFalloff, 0.1, depthDifference));
		occlusionSum += occlusionDepth * occlusionNormal;
	}
	float ssao = 1.0 - (occlusionSum * sampleWeight);

	o.color = float4(ssao, ssao, ssao, 1.0);

	//o.color = float4(1.0, 0.0, 1.0, 1.0);
}

/*
Blur structs and programs. It is basically a simple seperated blur filter with a
manually (not so sophisticated) choosen kernel. The big difference is, that the
kernel is only applied if the depth betwenn the current fragment and the sampled
fragment must be lower than a given threshold.
*/

const float FILTER[] = { 0.05, 0.1, 0.2, 0.3, 0.2, 0.1, 0.05 };

struct BlurVertexIn {
	float4 position : POSITION;
	float2 texcoord : TEXCOORD0;
};

struct BlurVertexOutFragmentIn {
	float4 position : POSITION;
	float2 texcoord : TEXCOORD0;
};

struct BlurFragmentOut {
	float4 color : COLOR;
};

void BlurVertexProgram(in BlurVertexIn i, out BlurVertexOutFragmentIn o) {
	o.position = i.position;
	o.texcoord = i.texcoord;
}

/*
TODO

Try to merge BlurHFragmentProgram and BlurVFragmentProgram.
*/
void BlurHFragmentProgram(in BlurVertexOutFragmentIn i, out BlurFragmentOut o, uniform sampler2D samplerColor, uniform sampler2D samplerNormalDepth) {
	const float2 scale = float2(1.0 / ViewPortPixelSize.x, 1.0 / ViewPortPixelSize.y);

	float currentColor = tex2D(samplerColor, i.texcoord).r;
	float currentDepth = tex2D(samplerNormalDepth, i.texcoord).w;

	float color = 0;
	for(int n = 0; n < 7; n++) {
		float2 st = i.texcoord + float2(scale.x * (n - 3), 0.0);
		float sampleColor = tex2D(samplerColor, st).r;
		float sampleDepth = tex2D(samplerNormalDepth, st).w;
		if(abs(sampleDepth - currentDepth) > SSAOBlurThreshold) {
			color += currentColor * FILTER[n];
		} else {
			color += sampleColor * FILTER[n];
		}
	}

	o.color = color;
}

void BlurVFragmentProgram(in BlurVertexOutFragmentIn i, out BlurFragmentOut o, uniform sampler2D samplerColor, uniform sampler2D samplerNormalDepth) {
	const float2 scale = float2(1.0 / ViewPortPixelSize.x, 1.0 / ViewPortPixelSize.y);

	float currentColor = tex2D(samplerColor, i.texcoord).r;
	float currentDepth = tex2D(samplerNormalDepth, i.texcoord).w;

	float color = 0;
	for(int n = 0; n < 7; n++) {
		float2 st = i.texcoord + float2(0.0, scale.y * (n - 3));
		float sampleColor = tex2D(samplerColor, st).r;
		float sampleDepth = tex2D(samplerNormalDepth, st).w;
		if(abs(sampleDepth - currentDepth) > SSAOBlurThreshold) {
			color += currentColor * FILTER[n];
		} else {
			color += sampleColor * FILTER[n];
		}
	}

	o.color = color;
}

// Technique

technique MyTechnique < string Script =
	"ClearSetColor=ClearColor;"
	"ClearSetDepth=ClearDepth;"

	"RenderColorTarget0=SceneNormalDepthTexture;"
	"RenderDepthStencilTarget=SceneDepthTexture;"
	"Clear=Color;"
	"Clear=Depth;"
	"Pass=MyNormalDepth;"

	"RenderColorTarget0=SceneColorTexture1;"
	"RenderDepthStencilTarget=SceneDepthTexture;"
	"Pass=MySSAO;"

	"RenderColorTarget0=SceneColorTexture2;"
	"RenderDepthStencilTarget=SceneDepthTexture;"
	"Pass=MyBlurH;"

	"RenderColorTarget0=;"
	"RenderDepthStencilTarget=;"
	"Pass=MyBlurV;";
	> {
	pass MyNormalDepth < string Script =
		"Draw=Geometry;";
	> {
		CullFaceEnable = true;
		DepthTestEnable = true;
		DepthMask = true;
		BlendEnable = false;
		VertexProgram = compile vp40 NormalDepthVertexProgram();
		FragmentProgram = compile fp40 NormalDepthFragmentProgram();
	}

	pass MySSAO < string Script =
		"Draw=Buffer;";
	> {
		CullFaceEnable = false;
		DepthTestEnable = false;
		DepthMask = false;
		BlendEnable = false;
		VertexProgram = compile vp40 SSAOVertexProgram();
		FragmentProgram = compile fp40 SSAOFragmentProgram(SceneNormalDepthSampler);
	}

	pass MyBlurH < string Script =
		"Draw=Buffer;";
	> {
		CullFaceEnable = false;
		DepthTestEnable = false;
		DepthMask = false;
		BlendEnable = false;
		VertexProgram = compile vp40 BlurVertexProgram();
		FragmentProgram = compile fp40 BlurHFragmentProgram(SceneColorSampler1, SceneNormalDepthSampler);
	}

	pass MyBlurV < string Script =
		"Draw=Buffer;";
	> {
		CullFaceEnable = false;
		DepthTestEnable = false;
		DepthMask = false;
		BlendEnable = false;
		VertexProgram = compile vp40 BlurVertexProgram();
		FragmentProgram = compile fp40 BlurVFragmentProgram(SceneColorSampler2, SceneNormalDepthSampler);
	}
}
